################################################################################
#
# RevBayes Example: Bayesian inference of rates of evolution under a
#                   relaxed-rate Brownian-motion model
#
#
# authors: Michael R. May and Sebastian HÃ¶hna
#
################################################################################

#######################
# Reading in the Data #
#######################
input_tree <- "tree.nex"
input_data <- "traits.nex"
output_file <- "simple_BM_nodes.log"
output_trees <- "simple_BM_nodes.trees"

### Select the trait to analyze
trait <- 1

##########################
# Specify the tree model #
##########################

### Read in the trees
T <- readTrees(input_tree)[1]
treeLength <- T.treeLength()
ntips <- T.ntips()
nnodes <- T.nnodes()
nbranches <- 2 * ntips - 2

for (i in nbranches:1) {
  branch_length[i] := T.branchLength(i) / treeLength
}
psi := fnTreeAssembly(T, branch_length)


### Read in the character data
data <- readContinuousCharacterData(input_data)
data.excludeAll()
data.includeCharacter(trait)

# Create some vector for the moves and monitors of this analysis
moves = VectorMoves()
monitors = VectorMonitors()
##########################
# Specify the rate model #
##########################

# specify the rate at the root
for (j in 1:data.ntaxa()) {
  vec_trait[j] <- data.get(j, 1)
}
# specify the rate parameter
sigma ~ dnLoguniform(var(vec_trait)^0.5 * 1e-4, var(vec_trait)^0.5 * 1e4)
moves.append(mvScale(sigma, weight = 1.0))

##########################
# Specify the BM process #
##########################
traitroot ~ dnUniform(min(vec_trait), max(vec_trait))
moves.append(mvSlide(traitroot,delta=10,tune=true,weight=2))

traits[nnodes] := traitroot
# univariate Brownian process along the tree
# parameterized by sigma
for (i in (nnodes-1):(ntips+1) ) {
  traits[i] ~ dnNormal( traits[psi.parent(i)], sd=sigma*sqrt(psi.branchLength(i)) )
  # moves on the Brownian process
  moves.append(mvSlide( traits[i], delta=10, tune=true, weight=2))
}

for (i in ntips:1 ) {
  traits[i] ~ dnNormal( traits[psi.parent(i)], sd=sigma*sqrt(psi.branchLength(i)) )
  # condition Brownian model on quantitative trait data (second column of the dataset)
  traits[i].clamp(data.getTaxon(psi.nodeName(i))[1])
}

#############
# The Model #
#############

mymodel = model(traits)

### set up the monitors that will output parameter values to file and screen
monitors.append(mnModel(filename = output_file, printgen = 10))
monitors.append(mnScreen(printgen = 1000, sigma, traitroot))
monitors.append(mnExtNewick(filename=output_trees, isNodeParameter=TRUE, printgen=100, separator=TAB, tree=T, traits) )

################
# The Analysis #
################

### workspace mcmc ###
mymcmc = mcmc(mymodel, monitors, moves, nruns = 2, combine = "mixed")

### run the MCMC ###
mymcmc.burnin(generations=1000, tuningInterval=10)
mymcmc.run(generations=10000, tuningInterval=100)

### quit ###
q()