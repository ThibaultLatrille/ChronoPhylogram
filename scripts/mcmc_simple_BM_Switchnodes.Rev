################################################################################
#
# RevBayes Example: Bayesian inference of rates of evolution under a
#                   relaxed-rate Brownian-motion model
#
#
# authors: Michael R. May and Sebastian HÃ¶hna
#
################################################################################

#######################
# Reading in the Data #
#######################
input_nuctree <- "tree_nuc.nex"
input_timetree <- "tree_time.nex"
input_data <- "traits.nex"
output_file <- "simple_BM_Switchnodes.log"

### Select the trait to analyze
trait <- 1

### Read in the trees
timeT <- readTrees(input_timetree)[1]
timeLenght <- timeT.treeLength()
nucT <- readTrees(input_nuctree)[1]
nucLength <- nucT.treeLength()
T <- readTrees(input_nuctree)[1]
ntips <- T.ntips()
nnodes <- T.nnodes()
nbranches <- 2 * ntips - 2


### Read in the character data
data <- readContinuousCharacterData(input_data)
data.excludeAll()
data.includeCharacter(trait)

# Create some vector for the moves and monitors of this analysis
moves = VectorMoves()
monitors = VectorMonitors()
##########################
# Specify the rate model #
##########################

# specify the rate at the root
sigma ~ dnLoguniform(1e-6, 1e6)
moves.append(mvScale(sigma, weight = 1.0))

##########################
# Specify the tree model #
##########################
# Move switch on whether the tree is nucleotide or time
is_nuc ~ dnBernoulli(0.5)
moves.append(mvBinarySwitch(is_nuc, weight = 1.0))
# specify the branch-specific rates

for (i in nbranches:1) {
  branch_length[i] := ifelse(is_nuc == TRUE, nucT.branchLength(i) / nucLength, timeT.branchLength(i) / timeLenght)
}

psi := fnTreeAssembly(T, branch_length)

bl_id <- 1
bl := branch_length[bl_id]
timebl := timeT.branchLength(bl_id) / timeLenght
nucbl := nucT.branchLength(bl_id) / nucLength

##########################
# Specify the BM process #
##########################
traitroot ~ dnUniform(-1000,1000)
moves.append(mvSlide(traitroot,delta=10,tune=true,weight=2))

traits[nnodes] := traitroot
# univariate Brownian process along the tree
# parameterized by sigma
for (i in (nnodes-1):(ntips+1) ) {
  traits[i] ~ dnNormal( traits[psi.parent(i)], sd=sigma*sqrt(branch_length[i]) )
  # moves on the Brownian process
  moves.append(mvSlide( traits[i], delta=10, tune=true ,weight=2))
}

for (i in ntips:1 ) {
  traits[i] ~ dnNormal( traits[psi.parent(i)], sd=sigma*sqrt(branch_length[i]) )
  # condition Brownian model on quantitative trait data (second column of the dataset)
  traits[i].clamp(data.getTaxon(psi.nodeName(i))[1])
}
#############
# The Model #
#############

mymodel = model(psi)

### set up the monitors that will output parameter values to file and screen
monitors.append(mnModel(filename = output_file, printgen = 10))
monitors.append(mnScreen(printgen = 1000, sigma, is_nuc, bl, timebl, nucbl))

################
# The Analysis #
################

### workspace mcmc ###
mymcmc = mcmc(mymodel, monitors, moves, nruns = 2, combine = "mixed")

### run the MCMC ###
mymcmc.burnin(generations=1000, tuningInterval=10)
mymcmc.run(generations=10000, tuningInterval=100)

q()